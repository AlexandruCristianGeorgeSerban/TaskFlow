package com.taskflow.ui;

import com.taskflow.model.Category;
import com.taskflow.model.RootGroup;
import com.taskflow.model.Task;
import com.taskflow.persistence.XmlDomHandler;
import com.taskflow.persistence.XmlSaxHandler;
import com.taskflow.service.TaskService;
import com.taskflow.action.*;

import javax.swing.*;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.table.TableRowSorter;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.TreePath;
import java.awt.*;
import java.io.File;
import java.util.List;

/** MainFrame expune toate metodele necesare acțiunilor */
public class MainFrame extends JFrame {
	private static final long serialVersionUID = 1L;
	
    private final TaskService taskService;
    private final TaskTableModel taskTableModel;
    private final CategoryTreeModel categoryTreeModel;
    private final JTable taskTable;
    private final JTree categoryTree;
    private final JTextField filterField;
    private final List<Task> masterTasks;

    public MainFrame(TaskService service) {
        super("TaskFlow");
        this.taskService       = service;
        this.taskTableModel    = new TaskTableModel(getAllTasks());
        this.masterTasks       = List.copyOf(getAllTasks());
        this.categoryTreeModel = new CategoryTreeModel(taskService.getAllRoots());

        // compontente
        taskTable = new JTable(taskTableModel);
        taskTable.setRowSorter(new TableRowSorter<>(taskTableModel));
        categoryTree = new JTree(categoryTreeModel);
        categoryTree.setRootVisible(false);
        categoryTree.setShowsRootHandles(true);
        categoryTree.setCellRenderer(new ColorTreeCellRenderer());
        filterField = new JTextField(15);

        // layout
        JSplitPane split = new JSplitPane(
            JSplitPane.HORIZONTAL_SPLIT,
            new JScrollPane(categoryTree),
            new JScrollPane(taskTable)
        );
        split.setDividerLocation(200);
        JPanel top = new JPanel(new FlowLayout(FlowLayout.LEFT));
        top.add(new JLabel("Filter:")); top.add(filterField);
        setLayout(new BorderLayout());
        add(top, BorderLayout.NORTH);
        add(split, BorderLayout.CENTER);

        // meniuri
        JMenuBar mb = new JMenuBar();
        mb.add(createFileMenu());
        mb.add(createRootMenu());
        mb.add(createCategoryMenu());
        mb.add(createTaskMenu());
        setJMenuBar(mb);

        // filtrare
        filterField.getDocument().addDocumentListener(new DocumentListener(){
            public void insertUpdate(DocumentEvent e){ applyFilter(); }
            public void removeUpdate(DocumentEvent e){ applyFilter(); }
            public void changedUpdate(DocumentEvent e){ applyFilter(); }
        });

        // selecție arbore
        categoryTree.addTreeSelectionListener(e -> {
            TreePath p = e.getNewLeadSelectionPath();
            if (p==null) return;
            Object o = ((DefaultMutableTreeNode)p.getLastPathComponent()).getUserObject();
            if      (o instanceof RootGroup) showTasks(getTasksFromRoot((RootGroup)o));
            else if (o instanceof Category ) showTasks(((Category)o).getTasks());
        });
        // dublu click pe task
        categoryTree.addMouseListener(new java.awt.event.MouseAdapter(){
            public void mouseClicked(java.awt.event.MouseEvent e){
                if (e.getClickCount()==2){
                    TreePath p = categoryTree.getPathForLocation(e.getX(),e.getY());
                    if (p!=null){
                        Object o = ((DefaultMutableTreeNode)p.getLastPathComponent()).getUserObject();
                        if (o instanceof Task) showTasks(List.of((Task)o));
                    }
                }
            }
        });

        setDefaultCloseOperation(EXIT_ON_CLOSE);
        setSize(800,600);
        setLocationRelativeTo(null);
    }

    // --- expun metodele de care au nevoie acțiunile:

    public TaskService getTaskService() {
        return taskService;
    }

    public JTable getTaskTable() {
        return taskTable;
    }
    public TaskTableModel getTaskTableModel() {
        return taskTableModel;
    }
    public List<Task> getMasterTasks() {
        return masterTasks;
    }

    public RootGroup createImportedRoot(List<Category> cats) {
        RootGroup imp = new RootGroup("Imported", "#0077CC");
        imp.getCategories().addAll(cats);
        return imp;
    }

    public boolean deleteRecursively(File f) {
        if (f.isDirectory()) {
            File[] ch = f.listFiles();
            if (ch!=null) for (File c: ch) if (!deleteRecursively(c)) return false;
        }
        return f.delete();
    }

    /** Reîmprospătează arborele şi tabelul cu toate taskurile. */
    public void refreshTreeAll() {
        categoryTreeModel.updateRoots(taskService.getAllRoots());
        showTasks(getAllTasks());
        expandAll();
    }

    /**
     * Reîmprospătează arborele și, dacă ai o categorie, afișează doar taskurile ei.
     * Dacă cat==null, afișează toate taskurile.
     */
    public void refreshAfterChange(Category cat) {
        categoryTreeModel.updateRoots(taskService.getAllRoots());
        if (cat != null) {
            showTasks(cat.getTasks());
        } else {
            showTasks(getAllTasks());
        }
        expandAll();
    }

    public void showError(Exception ex) {
        JOptionPane.showMessageDialog(this, ex.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);
    }

    // --- meniuri inline folosind clasele Action:
    private JMenu createFileMenu() {
    	JMenu fileMenu = new JMenu("File");
    	fileMenu.add(new ImportAction(this, new XmlSaxHandler()));
    	fileMenu.add(new ExportAction(this, new XmlDomHandler()));
    	fileMenu.addSeparator();
    	fileMenu.add(new DeleteFileAction(this));
        return fileMenu;
    }
    private JMenu createRootMenu() {
        JMenu m = new JMenu("Root");
        m.add(new AddRootAction(this));
        m.add(new EditRootAction(this));
        return m;
    }
    private JMenu createCategoryMenu() {
        JMenu m = new JMenu("Category");
        m.add(new AddCategoryAction(this));
        m.add(new EditCategoryAction(this));
        return m;
    }
    private JMenu createTaskMenu() {
        JMenu m = new JMenu("Task");
        m.add(new AddTaskAction(this));
        m.add(new EditTaskAction(this));
        m.addSeparator();
        m.add(new ToggleCompletedAction(this));
        m.addSeparator();
        m.add(new ResetOrderAction(this));
        return m;
    }

    // --- utilitare interne:
    private void applyFilter() {
        String t = filterField.getText().trim().toLowerCase();
        if (t.isEmpty()) refreshTreeAll();
        else taskTableModel.setTasks(
            getAllTasks().stream()
               .filter(x->x.getTitle().toLowerCase().contains(t)
                       || x.getDescription().toLowerCase().contains(t))
               .toList()
        );
    }
    private void showTasks(List<Task> tasks) {
        taskTableModel.setTasks(tasks);
    }
    private List<Task> getAllTasks() {
        return taskService.getAllRoots().stream()
            .flatMap(r->r.getCategories().stream())
            .flatMap(c->c.getTasks().stream())
            .toList();
    }
    private List<Task> getTasksFromRoot(RootGroup r) {
        return r.getCategories().stream()
            .flatMap(c->c.getTasks().stream())
            .toList();
    }
    
    /**
     * Returnează RootGroup-ul selectat în arbore (sau null).
     */
    public RootGroup getSelectedRoot() {
        TreePath p = categoryTree.getSelectionPath();
        if (p == null) return null;
        Object o = ((DefaultMutableTreeNode)p.getLastPathComponent()).getUserObject();
        return (o instanceof RootGroup) ? (RootGroup)o : null;
    }

    /** returnează categoria selectată în JTree (sau null) */
    public Category getSelectedCategory() {
        TreePath p = categoryTree.getSelectionPath();
        if (p == null) return null;
        Object o = ((DefaultMutableTreeNode)p.getLastPathComponent()).getUserObject();
        return (o instanceof Category) ? (Category)o : null;
    }

    /** returnează task-ul selectat în JTree (sau null) */
    public Task getSelectedTask() {
        TreePath p = categoryTree.getSelectionPath();
        if (p == null) return null;
        Object o = ((DefaultMutableTreeNode)p.getLastPathComponent()).getUserObject();
        return (o instanceof Task) ? (Task)o : null;
    }
    
    /**
     * Expand all rows din JTree.
     */
    public void expandAll() {
        SwingUtilities.invokeLater(() -> {
            for (int i = 0; i < categoryTree.getRowCount(); i++) {
                categoryTree.expandRow(i);
            }
        });
    }
}

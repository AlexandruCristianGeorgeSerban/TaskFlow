package com.taskflow.ui;

import com.taskflow.model.RootGroup;
import com.taskflow.model.Category;
import com.taskflow.model.Task;

import javax.swing.*;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeCellRenderer;
import java.awt.*;

public class ColorTreeCellRenderer extends DefaultTreeCellRenderer {
    private static final long serialVersionUID = 1L;
    private static final int SIZE = 12;

    @Override
    public Component getTreeCellRendererComponent(JTree tree, Object value,
          boolean sel, boolean expanded, boolean leaf, int row, boolean hasFocus) {
        super.getTreeCellRendererComponent(tree, value, sel, expanded, leaf, row, hasFocus);

        Object obj = ((DefaultMutableTreeNode) value).getUserObject();
        String hex = "#000000";

        if (obj instanceof RootGroup) {
            RootGroup rg = (RootGroup) obj;
            hex = rg.getColorHex();
            setText(rg.getName());
        } else if (obj instanceof Category) {
            Category c = (Category) obj;
            hex = c.getColor();
            setText(c.getName());
        } else if (obj instanceof Task) {
            Task t = (Task) obj;
            hex = t.isCompleted() ? "#00A000" : "#A00000";
            setText(t.getTitle());
        }

        final String colorHex = hex.trim().startsWith("#") ? hex.trim() : "#" + hex.trim();

        setIcon(new Icon() {
            @Override
            public void paintIcon(Component c, Graphics g, int x, int y) {
                Color col;
                try {
                    col = Color.decode(colorHex);
                } catch (NumberFormatException ex) {
                    col = Color.BLACK;
                }
                g.setColor(col);

                if (obj instanceof RootGroup) {
                    // PÄƒtrat
                    g.fillRect(x, y, SIZE, SIZE);

                } else if (obj instanceof Category) {
                    // Cerc
                    g.fillOval(x, y, SIZE, SIZE);

                } else if (obj instanceof Task) {
                    // Triunghi
                    int[] xs = { x, x + SIZE / 2, x + SIZE };
                    int[] ys = { y + SIZE, y, y + SIZE };
                    g.fillPolygon(xs, ys, 3);

                } else {
                    // Fallback: mic cerc
                    g.fillOval(x + SIZE/4, y + SIZE/4, SIZE/2, SIZE/2);
                }
            }

            @Override public int getIconWidth()  { return SIZE; }
            @Override public int getIconHeight() { return SIZE; }
        });

        return this;
    }
}

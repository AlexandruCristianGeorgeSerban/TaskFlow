package com.taskflow.ui;

import com.taskflow.model.RootGroup;
import com.taskflow.model.Category;
import com.taskflow.model.Task;
import com.taskflow.persistence.XmlDomHandler;
import com.taskflow.persistence.XmlSaxHandler;

import javax.swing.*;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.table.TableRowSorter;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.TreePath;
import java.awt.*;
import java.awt.event.*;
import java.io.File;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Main application window.
 */
@SuppressWarnings("serial")
public class MainFrame extends JFrame {
    private final List<RootGroup> allRoots;
    private TaskTableModel taskTableModel;
    private CategoryTreeModel categoryTreeModel;
    private JTable taskTable;
    private JTree categoryTree;
    private JTextField filterField;

    public MainFrame(List<RootGroup> roots) {
        super("TaskFlow");
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setSize(800, 600);
        setLocationRelativeTo(null);

        this.allRoots = new ArrayList<>(roots);
        
        // Models
        taskTableModel = new TaskTableModel(getAllTasks());
        categoryTreeModel = new CategoryTreeModel(allRoots);
        
        // Components
        taskTable = new JTable(taskTableModel);
        TableRowSorter<TaskTableModel> sorter = new TableRowSorter<>(taskTableModel);
        taskTable.setRowSorter(sorter);

        categoryTree = new JTree(categoryTreeModel);
        categoryTree.setRootVisible(false);      // ascunde nodul-rădăcină invizibil
        categoryTree.setShowsRootHandles(true);  // afișează însă „mânerele” pentru copii
        categoryTree.setCellRenderer(new ColorTreeCellRenderer());
        
        filterField = new JTextField(15);

        // Layout
        JSplitPane splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,
                new JScrollPane(categoryTree), new JScrollPane(taskTable));
        splitPane.setDividerLocation(200);

        JPanel topPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
        topPanel.add(new JLabel("Filter:"));
        topPanel.add(filterField);

        add(topPanel, BorderLayout.NORTH);
        add(splitPane, BorderLayout.CENTER);

        // Menus
        JMenuBar menuBar = new JMenuBar();
        menuBar.add(createFileMenu());
        menuBar.add(createRootMenu());
        menuBar.add(createCategoryMenu());
        menuBar.add(createTaskMenu());
        setJMenuBar(menuBar);

        // Filter listener
        filterField.getDocument().addDocumentListener(new DocumentListener() {
            @Override public void insertUpdate(DocumentEvent e) { applyFilter(); }
            @Override public void removeUpdate(DocumentEvent e) { applyFilter(); }
            @Override public void changedUpdate(DocumentEvent e) { applyFilter(); }
        });

        // Double-click listener on tree
        categoryTree.addMouseListener(new MouseAdapter() {
            public void mouseClicked(MouseEvent e) {
                if (e.getClickCount() == 2) {
                    TreePath path = categoryTree.getPathForLocation(e.getX(), e.getY());
                    if (path != null) {
                        Object node = ((DefaultMutableTreeNode) path.getLastPathComponent()).getUserObject();
                        if (node instanceof RootGroup) {
                            showTasks(getTasksFromRoot((RootGroup) node));
                        } else if (node instanceof Category) {
                            showTasks(((Category) node).getTasks());
                        } else if (node instanceof Task) {
                            showTasks(List.of((Task) node));
                        } else {
                            showTasks(getAllTasks());
                        }
                    }
                }
            }
        });
    }

    private JMenu createFileMenu() {
        JMenu fileMenu = new JMenu("File");
        fileMenu.add(new AbstractAction("Import XML") {
            @Override public void actionPerformed(ActionEvent e) {
                JFileChooser chooser = new JFileChooser();
                if (chooser.showOpenDialog(MainFrame.this) == JFileChooser.APPROVE_OPTION) {
                    File file = chooser.getSelectedFile();
                    try {
                    	// încărcăm pur și simplu categoriile
                    	List<Category> cats = new XmlSaxHandler().loadCategories(file);
                    	// le punem sub un singur root „Imported”
                    	RootGroup imported = new RootGroup("Imported", "#0077CC");
                    	imported.getCategories().addAll(cats);
                    	allRoots.clear();
                    	allRoots.add(imported);
                    	refreshTree();
                    } catch (Exception ex) {
                        showError(ex);
                    }
                }
            }
        });
        fileMenu.add(new AbstractAction("Export XML") {
            @Override public void actionPerformed(ActionEvent e) {
                JFileChooser chooser = new JFileChooser();
                if (chooser.showSaveDialog(MainFrame.this) == JFileChooser.APPROVE_OPTION) {
                    File file = chooser.getSelectedFile();
                    try {
                    	// extragem toate categoriile de sub toate root-urile
                    	List<Category> cats = allRoots.stream()
                    	.flatMap(rg -> rg.getCategories().stream())
                    	.toList();
                    	XmlDomHandler.saveCategories(cats, file);
                    } catch (Exception ex) {
                        showError(ex);
                    }
                }
            }
        });
        return fileMenu;
    }

    private JMenu createRootMenu() {
        JMenu rootMenu = new JMenu("Root");
        rootMenu.add(new AbstractAction("Add Root") {
            @Override public void actionPerformed(ActionEvent e) {
                // 1. Nume root
                String name = JOptionPane.showInputDialog(
                    MainFrame.this, "Root name:");
                if (name == null || name.trim().isEmpty()) return;

                // 2. Alegere culoare cu ColorChooser
                Color chosen = JColorChooser.showDialog(
                    MainFrame.this, "Choose root color", Color.BLACK);
                String colorHex = "#000000";
                if (chosen != null) {
                    colorHex = String.format(
                        "#%02x%02x%02x",
                        chosen.getRed(), chosen.getGreen(), chosen.getBlue()
                    );
                }

                // 3. Creează și adaugă root-ul
                RootGroup rg = new RootGroup(name.trim(), colorHex);
                allRoots.add(rg);
                refreshTree();
            }
        });
        return rootMenu;
    }

    private JMenu createCategoryMenu() {
        JMenu categoryMenu = new JMenu("Category");
        categoryMenu.add(new AbstractAction("Add Category") {
            @Override public void actionPerformed(ActionEvent e) {
                // 1. Alege root-ul în care adaugi categoria
                TreePath sel = categoryTree.getSelectionPath();
                if (sel == null) {
                    JOptionPane.showMessageDialog(
                        MainFrame.this,
                        "Select a root to add a category.",
                        "Info",
                        JOptionPane.INFORMATION_MESSAGE
                    );
                    return;
                }
                Object obj = ((DefaultMutableTreeNode) sel.getLastPathComponent())
                                  .getUserObject();
                if (!(obj instanceof RootGroup)) {
                    JOptionPane.showMessageDialog(
                        MainFrame.this,
                        "Please select a root.",
                        "Info",
                        JOptionPane.INFORMATION_MESSAGE
                    );
                    return;
                }
                RootGroup rg = (RootGroup) obj;

                // 2. Nume categorie
                String name = JOptionPane.showInputDialog(
                    MainFrame.this, "Category name:");
                if (name == null || name.trim().isEmpty()) return;

                // 3. Alegere culoare cu ColorChooser
                Color chosen = JColorChooser.showDialog(
                    MainFrame.this, "Choose category color", Color.BLUE);
                String colorHex = "#0000FF";
                if (chosen != null) {
                    colorHex = String.format(
                        "#%02x%02x%02x",
                        chosen.getRed(), chosen.getGreen(), chosen.getBlue()
                    );
                }

                // 4. Creează categoria și o adaugă la root
                Category cat = new Category(name.trim(), colorHex);
                rg.getCategories().add(cat);
                refreshTree();
            }
        });
        return categoryMenu;
    }

    private JMenu createTaskMenu() {
        JMenu taskMenu = new JMenu("Task");
        taskMenu.add(new AbstractAction("Add Task") {
            @Override public void actionPerformed(ActionEvent e) {
                addTaskDialog();
            }
        });
        return taskMenu;
    }

    private void applyFilter() {
        String text = filterField.getText().trim().toLowerCase();
        if (text.isEmpty()) {
            taskTableModel.setTasks(getAllTasks());
            refreshTree();
        } else {
            List<Task> filtered = getAllTasks().stream()
                    .filter(t -> t.getTitle().toLowerCase().contains(text)
                            || t.getDescription().toLowerCase().contains(text))
                    .collect(Collectors.toList());
            taskTableModel.setTasks(filtered);

            // filter tree not implemented for brevity
        }
    }

    private List<Task> getAllTasks() {
        return allRoots.stream()
                .flatMap(rg -> rg.getCategories().stream())
                .flatMap(c -> c.getTasks().stream())
                .toList();
    }

    private List<Task> getTasksFromRoot(RootGroup rg) {
        return rg.getCategories().stream()
                .flatMap(c -> c.getTasks().stream())
                .toList();
    }

    private List<Task> getTasksFromCategory(Category cat) {
        return new ArrayList<>(cat.getTasks());
    }

    private void refreshTree() {
        // 1) Reconstruiește modelul
        categoryTreeModel.updateRoots(allRoots);
        // 2) Asigură-te că se execută după actualizarea UI
        SwingUtilities.invokeLater(() -> {
            // expandăm toate rândurile noului model
            for (int i = 0; i < categoryTree.getRowCount(); i++) {
                categoryTree.expandRow(i);
            }
        });
    }

    private void showTasks(List<Task> tasks) {
        taskTableModel.setTasks(tasks);
    }

    private void showError(Exception ex) {
        JOptionPane.showMessageDialog(this,
                ex.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);
    }
    
    private void addTaskDialog() {
        // Verifică selecția unui nod
        TreePath sel = categoryTree.getSelectionPath();
        if (sel == null) {
            JOptionPane.showMessageDialog(this,
                "Select a category to add a task.",
                "Info", JOptionPane.INFORMATION_MESSAGE);
            return;
        }
        Object obj = ((DefaultMutableTreeNode) sel.getLastPathComponent()).getUserObject();
        if (!(obj instanceof Category)) {
            JOptionPane.showMessageDialog(this,
                "Please select a category node.",
                "Info", JOptionPane.INFORMATION_MESSAGE);
            return;
        }
        Category cat = (Category) obj;

        // Titlu și descriere
        String title = JOptionPane.showInputDialog(this, "Task title:");
        if (title == null || title.trim().isEmpty()) return;
        String desc = JOptionPane.showInputDialog(this, "Task description:");
        if (desc == null) desc = "";

        // Data-limită
        String dueStr = JOptionPane.showInputDialog(this,
        	    "Due date (yyyy-MM-dd or yyyyMMdd):");
        	Calendar dueDate;
        	try {
        	    Date d;
        	    if (dueStr.contains("-")) {
        	        d = new SimpleDateFormat("yyyy-MM-dd").parse(dueStr);
        	    } else if (dueStr.length() == 8) {
        	        d = new SimpleDateFormat("yyyyMMdd").parse(dueStr);
        	    } else {
        	        throw new ParseException("Format invalid", 0);
        	    }
        	    dueDate = Calendar.getInstance();
        	    dueDate.setTime(d);
        	} catch (ParseException ex) {
        	    JOptionPane.showMessageDialog(this,
        	        "Invalid date format.\nUse yyyy-MM-dd or yyyyMMdd",
        	        "Error", JOptionPane.ERROR_MESSAGE);
        	    return;
        	}

        // Alege culoarea cu un Color Chooser
        Color chosen = JColorChooser.showDialog(
            this, "Choose task color", Color.RED);
        // Dacă utilizatorul a apăsat Cancel, folosește default
        String colorHex = "#A00000";
        if (chosen != null) {
            colorHex = String.format(
                "#%02x%02x%02x",
                chosen.getRed(), chosen.getGreen(), chosen.getBlue());
        }

        // Creează și adaugă task-ul
        Task t = new Task(
            title.trim(),
            desc.trim(),
            dueDate,
            false,
            colorHex
        );
        cat.addTask(t);

        // Actualizează arborele și tabelul
        refreshTree();
        taskTableModel.setTasks(getTasksFromCategory(cat));
    }
}

package com.taskflow.ui;

import com.taskflow.model.RootGroup;
import com.taskflow.model.Category;
import com.taskflow.model.Task;

import javax.swing.*;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeCellRenderer;
import java.awt.*;

/**
 * Renderer care afișează forme colorate diferite pentru RootGroup, Category și Task.
 */
public class ColorTreeCellRenderer extends DefaultTreeCellRenderer {
    private static final long serialVersionUID = 1L;
    private static final int SIZE = 12;

    @Override
    public Component getTreeCellRendererComponent(JTree tree,
            Object value, boolean selected, boolean expanded,
            boolean leaf, int row, boolean hasFocus) {

        super.getTreeCellRendererComponent(
            tree, value, selected, expanded, leaf, row, hasFocus);

        Object obj = ((DefaultMutableTreeNode) value).getUserObject();
        String rawHex;
        String label;

        if (obj instanceof RootGroup) {
            RootGroup rg = (RootGroup) obj;
            rawHex = rg.getColorHex();      // metoda deja definită pe RootGroup
            label = rg.getName();
        } else if (obj instanceof Category) {
            Category c = (Category) obj;
            rawHex = c.getColor();          // folosește getColor() din Category
            label = c.getName();
        } else if (obj instanceof Task) {
            Task t = (Task) obj;
            rawHex = t.isCompleted() ? "#00A000" : "#A00000";
            label = t.getTitle();
        } else {
            rawHex = "#000000";
            label = obj.toString();
        }

        // Normalizează hex: elimină spații și asigură #
        String colorHex = rawHex != null ? rawHex.trim() : "";
        if (!colorHex.startsWith("#")) {
            colorHex = "#" + colorHex;
        }

        final Color shapeColor;
        try {
            shapeColor = Color.decode(colorHex);
        } catch (NumberFormatException ex) {
            shapeColor = Color.BLACK;
        }

        setText(label);

        // Icon personalizat: formă diferită per tip de nod
        setIcon(new Icon() {
            @Override
            public void paintIcon(Component c, Graphics g, int x, int y) {
                g.setColor(shapeColor);
                if (obj instanceof RootGroup) {
                    // pătrat
                    g.fillRect(x, y, SIZE, SIZE);
                } else if (obj instanceof Category) {
                    // cerc
                    g.fillOval(x, y, SIZE, SIZE);
                } else if (obj instanceof Task) {
                    // triunghi
                    int[] xs = { x, x + SIZE/2, x + SIZE };
                    int[] ys = { y + SIZE, y, y + SIZE };
                    g.fillPolygon(xs, ys, 3);
                } else {
                    // fallback: mic cerc
                    g.fillOval(x + SIZE/4, y + SIZE/4, SIZE/2, SIZE/2);
                }
            }

            @Override public int getIconWidth()  { return SIZE; }
            @Override public int getIconHeight() { return SIZE; }
        });

        return this;
    }
}
